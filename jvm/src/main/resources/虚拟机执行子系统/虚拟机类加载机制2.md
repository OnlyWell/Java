### 1.类加载的过程
#### 1.1加载
##### 1>通过一个类的全限定名来获取此定义类的二进制字节流
##### 2>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
##### 3>在java堆中生成一个代表这个类的java.lang.Class对象,作为方法区这些数据的访问入口
#### 1.2验证
##### 验证是连接阶段的第一步.不同虚拟机对类验证的实现会有不同,但是会完成下面四个阶##### 段的检验过程
	i>文件格式验证
		-	是否以魔数开头
		-	主次版本号是否在当前虚拟机处理范围内
		-	指向常量的各种索引值中是否有不存在的常量或不服类型的常量
		-	CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据
		-	Class文件中各个部分及文件本身是否有被删除的或附加的其他信息.
		-	....
	ii>元数据验证
		- 	该类是否有父类(java.lang.Object除外,所有的类都应当有父类)
		-	该类是否继承了不允许被继承的类(final修饰)
		-	....
	iii>字节码验证
		- 	保证跳转指令不会调到方法体意外的字节码指令上
	iiii>符号引用验证
		- 	符号引用中通过字符串描述的全限定名是否能找到对应的类
#### 1.3准备
	准备阶段是正式为类变量分配内存并设置类变量初始值的阶段.,这些内存都将在方法区中进行分配(仅指类变量,被static修饰的变量,不包括实例变量,实例变量将会在对象实例化时随着对象一起分配在java堆中)
	eg: public static int value = 123;
	value在准备阶段过后的初始值是0而不是123,因为这时候尚未开始执行任何java方法,而把value赋值为123的putstatic指令是程序被编译后,存放于类构造器<clinit>()方法中,所以把value赋值为123的动作将在初始化阶段才会被执行.."通常情况下"初始值是零值,特殊情况如类字段的字段属性表中存在ConstantValue属性,那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值
	eg: public static final int value = 123;
	javac时就会为value生成ConstantValue属性
	
	基本数据类型的零值:
	int						0
	long 					0L
	short					(short)0
	char					'\u0000'
	byte					(byte)0
	boolean					false
	float					0.0f
	double					0.0d
	reference				null
#### 1.4解析
	解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程,符号引用在Class文件中以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现.
	符号引用(Symbolic References):符号引用以一组符号来描述所引用的目标,符号可以是任何形式的字面量,只要使用时能无歧义地定位到目标即可.符号引用与虚拟机实现的内存布局无关,引用的目标不一定已经加载到内存中.
	直接引用(Direct References):直接引用可以是直接指向目标的指针,相对偏移量或是一个能间接定位到目标的句柄.直接引用是与虚拟机实现的内存布局相关的,同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同.如果有了直接引用,那引用的目标必定已经在内存中存在.
	
#### 1.5初始化
	类初始化是类加载过程的最后一步,初始化阶段是执行类构造器<clinit>()方法的过程.
	i><clinit>()方法是由编译器自动收集类中的所有变量的赋值动作和静态语句块(static{}块)中的语句合并产生的,编译器收集的顺序是由语句在源文件中出现的顺序所决定的.静态语句块中只能访问到定义在静态语句块之前的变量,定义在它之后的变量,在前面的静态语句跨中可以赋值,但是不能访问.
	ii><clinit>()方法与类的构造函数不同,它不需要显式地调用父类构造器,虚拟机会在保证子类的<clinit>()方法执行之前,父类的<clinit>()方法已经执行完毕.因此在虚拟机中第一个被执行的<clinit>()方法的类肯定是java.lang.Object
	iii>由于父类的<clinit>()方法先执行,也就意味着父类中定义的静态语句块要优于子类的变量赋值操作.
	
	&&&& 如果一个勒种没有静态语句块,也没有对变量的赋值操作,那么编译器可以不为这个类生成<clinit>()方法..
	&&&& 接口中的<clinit>()方法不需要先之心父接口的<clinit>方法.只有当父接口中定义的变量被使用时,父接口才会被初始化.
	&&&& 虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确的加锁同步,如果多个线程同时去初始化一个类,那么只会有一个线程去执行这个类的<clinit>()方法,其他线程都需要阻塞等待.

#### 2.类加载器
#### 2.1类与类加载器
#### 2.2双亲委派模型
	1>启动类加载器(Bootstrap ClassLoader)
	2>扩展类加载器(Extension ClassLoader)
	3>应用程序类加载(Application ClassLoader):
#### 2.3

	
	
	
	
	
	
	
	
	
	
	